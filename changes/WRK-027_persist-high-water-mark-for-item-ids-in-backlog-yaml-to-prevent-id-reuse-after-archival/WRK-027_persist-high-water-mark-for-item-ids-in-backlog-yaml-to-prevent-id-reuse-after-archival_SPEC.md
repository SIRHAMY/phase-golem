# SPEC: Persist High-Water Mark for Item IDs

**ID:** WRK-027
**Status:** Complete
**Created:** 2026-02-12
**PRD:** ./WRK-027_persist-high-water-mark-for-item-ids-in-backlog-yaml-to-prevent-id-reuse-after-archival_PRD.md
**Execution Mode:** autonomous
**New Agent Per Phase:** no
**Max Review Attempts:** 3

## Context

Item IDs are generated by scanning current backlog items for the highest numeric suffix and incrementing. When items are archived (removed from `BACKLOG.yaml`), the scan no longer sees them, allowing ID reuse. This is a data integrity issue that worsens over time. The fix is a classic high-water mark pattern: persist the highest suffix ever assigned so ID generation never regresses.

The codebase already provides all required infrastructure — atomic writes via `NamedTempFile` + `sync_all()` + `persist()`, and `#[serde(default)]` for backward-compatible field addition. No new dependencies or architectural changes are needed.

## Approach

Add a `next_item_id: u32` field to `BacklogFile` with `#[serde(default)]` (defaults to 0 when absent). Update `generate_next_id()` to incorporate this field as a floor in the max computation via `max(current_items_max, next_item_id) + 1`, and change its return type to `(String, u32)` so callers can write back the new high-water mark. Update the two callers (`add_item()` and `ingest_follow_ups()`) to destructure the tuple and set `backlog.next_item_id` after each call. The existing `save()` function automatically serializes the new field — no changes needed.

**Patterns to follow:**

- `orchestrator/src/types.rs:193` — existing `#[serde(default)]` on `items` field demonstrates the backward-compatible field addition pattern
- `orchestrator/src/backlog.rs:85-105` — existing `generate_next_id()` pure function pattern (read-only, returns computed value)
- `orchestrator/src/backlog.rs:242` — existing `.map()` closure in `ingest_follow_ups()` that mutates `backlog.items` via `push()` inside the closure
- `orchestrator/tests/backlog_test.rs:52-57` — `empty_backlog()` helper pattern for test setup

**Implementation boundaries:**

- Do not modify: `save()` or `load()` functions — the new field is automatically handled by serde serialization
- Do not modify: `BacklogSnapshot` struct — it is a read-only view not used for ID generation
- Do not refactor: `.map()` to `for` loop in `ingest_follow_ups()` — consistency with existing code; refactoring is out of scope

## Open Questions

None — the PRD and design doc are highly detailed with no ambiguity. All decisions have been made.

## Phase Summary

| Phase | Name | Complexity | Description |
|-------|------|------------|-------------|
| 1 | Core Implementation | Low | Add `next_item_id` field, update `generate_next_id()` return type, update callers |
| 2 | Tests | Low | Update existing test call sites, add new unit tests for high-water mark behavior, add integration test |

**Ordering rationale:** Phase 1 must complete before Phase 2 because the test updates depend on the new struct field and function signature. All production code changes are tightly coupled (struct → function → callers) and should be done together to maintain compilability.

---

## Phases

Each phase should leave the codebase in a functional, stable state. Complete and verify each phase before moving to the next.

---

### Phase 1: Core Implementation

> Add `next_item_id` field to `BacklogFile`, update `generate_next_id()` to use it, and update callers

**Phase Status:** complete

**Complexity:** Low

**Goal:** Implement the high-water mark persistence so that ID generation incorporates the persisted floor and callers write back the new value after each generation.

**Files:**

- `orchestrator/src/types.rs` — modify — Add `next_item_id: u32` field with `#[serde(default)]` to `BacklogFile` struct
- `orchestrator/src/backlog.rs` — modify — Update `generate_next_id()` signature and logic, update `add_item()` and `ingest_follow_ups()` callers

**Tasks:**

- [x] Add `next_item_id: u32` field to `BacklogFile` struct in `types.rs` with `#[serde(default)]` attribute and a doc comment explaining it stores the highest numeric suffix ever assigned (used as floor for ID generation)
- [x] Update `generate_next_id()` in `backlog.rs`: change return type from `String` to `(String, u32)`, update max computation to `max(current_items_max, backlog.next_item_id) + 1`, return both the formatted ID string and the new numeric suffix
- [x] Update `add_item()` in `backlog.rs`: destructure `generate_next_id()` return as `let (id, suffix) = generate_next_id(backlog, prefix);`, add `backlog.next_item_id = suffix;` immediately after
- [x] Update `ingest_follow_ups()` in `backlog.rs`: destructure `generate_next_id()` return as `let (id, suffix) = generate_next_id(backlog, prefix);` inside the `.map()` closure, add `backlog.next_item_id = suffix;` inside the closure before the `items.push()` call

**Verification:**

- [x] Production code compiles without errors (`cargo build`)
- [x] Note: test code in `backlog_test.rs` will fail to compile due to the `generate_next_id()` return type change — this is expected and fixed in Phase 2. Use `cargo check --lib` to verify only production code compiles.

**Commit:** `[WRK-027][P1] Feature: Add next_item_id high-water mark to BacklogFile and update ID generation`

**Notes:**

The `next_item_id` field persists the highest numeric suffix ever assigned. It serves as a floor for ID generation — the formula `max(current_items_max, next_item_id) + 1` ensures the next ID always exceeds all previously assigned IDs. The field name `next_item_id` is a PRD schema decision; a doc comment on the struct field clarifies the semantics for developers.

In `ingest_follow_ups()`, the `backlog.next_item_id = suffix` assignment must happen inside the `.map()` closure (before the next iteration) to ensure each subsequent `generate_next_id()` call sees the updated floor. This mirrors the existing `backlog.items.push()` pattern already in the closure.

**Followups:**

---

### Phase 2: Tests

> Update existing test call sites for tuple return, add new unit and integration tests for high-water mark behavior

**Phase Status:** complete

**Complexity:** Low

**Goal:** Ensure all existing tests pass with the new return type and add comprehensive tests covering the high-water mark scenarios from the PRD success criteria.

**Files:**

- `orchestrator/tests/backlog_test.rs` — modify — Update `empty_backlog()` helper, update 6 existing test call sites, add 7 new unit tests and 1 integration test

**Patterns:**

- Follow existing test structure in `backlog_test.rs` using `empty_backlog()` helper and `make_item()` for setup
- Follow existing assertion patterns: `assert_eq!` for exact value checks

**Tasks:**

- [x] Update `empty_backlog()` helper to include `next_item_id: 0` in the `BacklogFile` struct initialization
- [x] Update all existing `generate_next_id()` test call sites (in tests `generate_id_empty_backlog`, `generate_id_sequential`, `generate_id_with_gaps`, `generate_id_zero_padding`, `generate_id_different_prefix_ignored`, `generate_id_non_numeric_suffix_ignored`) to destructure the tuple return: `let (id, _suffix) = backlog::generate_next_id(...)` and assert on `id`
- [x] Add test: empty backlog with `next_item_id` set (e.g., `next_item_id: 5`) — verify generates `WRK-006` and returns suffix `6`
- [x] Add test: backlog where current items max exceeds `next_item_id` (e.g., items up to `WRK-010`, `next_item_id: 3`) — verify generates `WRK-011` and returns suffix `11`
- [x] Add test: backlog where `next_item_id` exceeds current items max (e.g., items up to `WRK-003`, `next_item_id: 10`) — verify generates `WRK-011` and returns suffix `11`
- [x] Add test: multiple sequential ID generations in a single session — generate 3 IDs on empty backlog, verify they are `WRK-001`, `WRK-002`, `WRK-003` with correct suffixes and `next_item_id` values of `1`, `2`, `3` respectively, simulating the caller updating `backlog.next_item_id` and pushing items between calls
- [x] Add test: `add_item()` updates `next_item_id` — call `add_item()` twice on an empty backlog, assert `backlog.next_item_id == 1` after first call and `backlog.next_item_id == 2` after second
- [x] Add test: `ingest_follow_ups()` updates `next_item_id` sequentially — ingest 3 follow-ups on an empty backlog, verify generated IDs are `WRK-001`, `WRK-002`, `WRK-003` and `backlog.next_item_id == 3` after ingestion
- [x] Add test: no ID reuse after archival — add items `WRK-001` through `WRK-003`, simulate archival by clearing `backlog.items` while keeping `next_item_id = 3`, generate next ID, verify it is `WRK-004`
- [x] Add integration test (PRD Should-Have): write a temporary YAML file with `schema_version: 2\nitems: []` (no `next_item_id` field), load it via `backlog::load()`, verify `next_item_id` defaults to 0, generate an ID, call `save()`, reload the file, verify `next_item_id` is persisted in the YAML and equals the generated suffix

**Verification:**

- [x] All existing tests pass (no regressions from tuple return change)
- [x] All new tests pass
- [x] Full test suite passes: `cargo test`
- [x] Code review passes (`/code-review` → fix issues → repeat until pass)

**Commit:** `[WRK-027][P2] Feature: Add high-water mark tests and update existing test call sites`

**Notes:**

For the sequential generation test, simulate what callers do: after each `generate_next_id()` call, update `backlog.next_item_id` with the returned suffix and push the item to `backlog.items`. This mirrors the real `add_item()` flow and verifies the complete cycle.

For the integration test, use `tempfile` (already a dev dependency) to create a temporary YAML file. Write a minimal YAML string inline (e.g., `"schema_version: 2\nitems: []\n"`) without the `next_item_id` field, then exercise the load → generate → save → reload cycle. Assert both the deserialized struct value and the raw YAML content after save.

Crash safety is guaranteed by the existing atomic-write pattern in `save()` — the item and `next_item_id` are serialized together via `NamedTempFile` + `sync_all()` + `persist()`. If a crash occurs before `save()`, neither the item nor the high-water mark persists, so no collision is possible on restart. No additional crash-safety tests are needed beyond the existing `save()` tests.

**Followups:**

---

## Final Verification

- [x] All phases complete
- [x] All PRD success criteria met:
  - [x] `BacklogFile` includes `next_item_id: u32` with `#[serde(default)]`
  - [x] `generate_next_id()` computes `max(current_items_max, next_item_id) + 1`
  - [x] `generate_next_id()` returns `(String, u32)` (pure, no mutation)
  - [x] Callers update `backlog.next_item_id` immediately after each call
  - [x] Existing YAML files without field load successfully (default 0)
  - [x] Field serialized on every `save()` call
  - [x] No ID collision after archiving all items
  - [x] Unit tests cover all 4 required scenarios (empty+HWM, current>HWM, HWM>current, sequential)
  - [x] Caller tests verify `add_item()` and `ingest_follow_ups()` update `next_item_id`
  - [x] Archival scenario test verifies no ID reuse
  - [x] Integration test covers backward-compatible load (Should Have)
- [x] Tests pass
- [x] No regressions introduced
- [x] Code reviewed (if applicable)

## Execution Log

| Phase | Status | Commit | Notes |
|-------|--------|--------|-------|
| 1 | complete | (combined with P2) | Core implementation: struct field, function signature, callers. Also updated migration.rs and main.rs initializers. |
| 2 | complete | (combined with P1) | Tests: updated 6 existing call sites + 5 other test files with BacklogFile initializers, added 8 new tests (7 unit + 1 integration). All 368 tests pass. |

## Followups Summary

### Critical

(none)

### High

(none)

### Medium

(none)

### Low

- [ ] Validation on load: if `next_item_id < max(current items)`, log warning and auto-correct (PRD Nice-to-Have) — deferred as `generate_next_id()` formula self-corrects via `max()` (Phase 1)

## Design Details

### Key Types

```rust
// Modified struct — orchestrator/src/types.rs
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
pub struct BacklogFile {
    pub schema_version: u32,
    #[serde(default)]
    pub items: Vec<BacklogItem>,
    /// Highest numeric suffix ever assigned for ID generation.
    /// Used as a floor in generate_next_id() to prevent ID reuse after archival.
    /// Formula: next_id = max(current_items_max, next_item_id) + 1
    #[serde(default)]
    pub next_item_id: u32,
}
```

```rust
// Modified function signature — orchestrator/src/backlog.rs
pub fn generate_next_id(backlog: &BacklogFile, prefix: &str) -> (String, u32) {
    let prefix_with_dash = format!("{}-", prefix);
    let max_num = backlog
        .items
        .iter()
        .filter_map(|item| {
            item.id
                .strip_prefix(&prefix_with_dash)
                .and_then(|suffix| suffix.parse::<u32>().ok())
        })
        .max()
        .unwrap_or(0)
        .max(backlog.next_item_id);
    let next = max_num + 1;
    (format!("{}-{:03}", prefix, next), next)
}
```

### Design Rationale

See the Design doc for full rationale. Key points:
- **Tuple return over mutation:** Preserves existing pure-function pattern. Callers already have `&mut BacklogFile`.
- **`.map()` over `for` loop:** Consistency with existing code pattern in `ingest_follow_ups()`.
- **`next_item_id` naming:** PRD schema decision. Stores highest assigned suffix, not literally the next value. Code comment clarifies.
- **No schema version bump:** Additive optional field with `#[serde(default)]` is backward-compatible.

## Assumptions

- **Autonomous mode:** No human available for input. All decisions made based on PRD, design doc, and codebase analysis.
- **Mode selection:** Light mode — the change is small (2 source files, 1 test file), well-understood, and the PRD/design are highly detailed.
- **BacklogSnapshot exclusion:** The `BacklogSnapshot` struct does NOT need `next_item_id` because it is a read-only view not used for ID generation.
- **Test fixture approach:** The integration test will use `tempfile` to create a temporary YAML file at runtime rather than adding a static fixture file, reducing file bloat.
