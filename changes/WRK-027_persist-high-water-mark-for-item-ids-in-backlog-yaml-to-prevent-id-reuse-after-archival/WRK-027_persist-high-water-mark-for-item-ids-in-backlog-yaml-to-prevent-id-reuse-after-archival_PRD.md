# Change: Persist High-Water Mark for Item IDs

**Status:** Proposed
**Created:** 2026-02-12
**Author:** Orchestrator (autonomous)

## Problem Statement

Item IDs follow the format `PREFIX-NNN` (e.g., `WRK-001`) where the prefix comes from `orchestrate.toml` and `NNN` is a zero-padded numeric suffix. IDs are generated by `generate_next_id()` in `backlog.rs`, which scans all current items in the backlog for the highest numeric suffix and increments it. When items reach `Done` status, they are archived — removed from `BACKLOG.yaml` and written to the worklog (a persistent record of completed items). After archival, the max-ID scan no longer sees those items.

If all items in the backlog are archived (or enough high-numbered items are archived), the next generated ID can collide with a previously-used ID. In the worst case — an empty backlog — the next ID resets to `WRK-001`, which may already exist in the worklog and on disk as a `changes/` directory.

This causes:
- **Worklog corruption:** Archived entries reference one item, but a new item reuses the same ID, making worklog history ambiguous.
- **Change directory conflicts:** The `changes/WRK-001_…/` directory from the original item still exists on disk. A new item with ID `WRK-001` would either collide with it or create a confusingly similar directory.
- **Broken references:** Phase results, commit messages, and other artifacts reference IDs that now map to two different items.

This is a data integrity issue that worsens over time as more items are archived.

## User Stories / Personas

- **Orchestrator operator** — Runs the orchestrator for long sessions that generate, complete, and archive many items. Needs confidence that IDs are globally unique and stable references, even after archival clears them from the active backlog.

## Desired Outcome

After this change, item IDs are never reused. The orchestrator persists a high-water mark (the highest numeric suffix ever assigned) and uses it as a floor when generating new IDs, regardless of which items are currently in the backlog.

Existing `BACKLOG.yaml` files without the new field load successfully with the field defaulting to 0. On first ID generation, the current-items scan produces the correct value, and the high-water mark is persisted on the next save — no manual intervention required.

## Success Criteria

### Must Have

- [ ] `BacklogFile` includes a `next_item_id: u32` field that persists the next available numeric suffix
- [ ] The field name is `next_item_id` (storing the next numeric suffix to assign, not the last one assigned) to avoid off-by-one confusion — this is a schema decision that is hard to change later
- [ ] `generate_next_id()` computes the next ID as `max(current_items_max, next_item_id) + 1` where `current_items_max` is the highest numeric suffix among current backlog items
- [ ] `generate_next_id()` returns both the generated ID string and the new numeric suffix, allowing the caller to update `BacklogFile.next_item_id` — the function itself remains pure (no mutation of BacklogFile)
- [ ] Callers of `generate_next_id()` update `backlog.next_item_id` with the returned suffix immediately after each call
- [ ] Existing `BACKLOG.yaml` files without the field load successfully via `serde(default)`, defaulting to 0 — on first ID generation, `max(0, current_items_max)` produces the correct floor
- [ ] The field is serialized to `BACKLOG.yaml` on every `save()` call, so it persists across restarts
- [ ] After archiving all items and generating a new one, the new ID does not collide with any previously used ID
- [ ] Unit tests cover: (a) empty backlog with high-water mark set, (b) backlog where current max exceeds high-water mark, (c) backlog where high-water mark exceeds current max, (d) multiple sequential ID generations in a single session

### Should Have

- [ ] Integration test: load a `BACKLOG.yaml` without `next_item_id`, generate an ID, verify the field appears in the saved YAML and the ID is correct

### Nice to Have

- [ ] Validation on load: if `next_item_id` is present but less than the max current item suffix, log a warning and auto-correct to the higher value

## Scope

### In Scope

- Adding a `next_item_id: u32` field to `BacklogFile` with `#[serde(default)]`
- Updating `generate_next_id()` to incorporate the persisted value and return the new suffix
- Updating callers (`ingest_follow_ups()` and any others) to write back the new high-water mark after each call
- Ensuring the field is saved to YAML via the existing `save()` path
- Unit tests for the updated logic

### Out of Scope

- Scanning the worklog to retroactively compute the high-water mark for existing backlogs — the current-items scan provides a safe floor, and the high-water mark will be correct going forward. If a user has an empty backlog and archived items in the worklog, the first new ID may be lower than archived IDs; this is a one-time migration gap that is acceptable given the low likelihood and the field becoming correct immediately after
- Changing the ID format (e.g., switching from numeric to UUID)
- Multi-prefix support (each prefix getting its own counter) — current codebase uses a single prefix from `orchestrate.toml`. If multi-prefix support is added later, `next_item_id` would need to become a map; this is accepted technical debt
- Schema version bump — adding an optional field with `#[serde(default)]` is backward-compatible and does not require a v2-to-v3 migration
- Concurrent orchestrator instances — only one orchestrator process is expected to run at a time; concurrent access is not supported and is out of scope
- Numeric overflow handling — `u32` supports up to 4,294,967,295 IDs which is sufficient; overflow is not a realistic concern

## Non-Functional Requirements

- **Performance:** Negligible — adds one integer comparison to ID generation and one integer field to YAML serialization.
- **Data Safety:** The high-water mark is persisted atomically with the rest of `BACKLOG.yaml` via the existing atomic-write-via-tempfile pattern in `save()` (write to temp file, fsync, rename). If a crash occurs after ID generation but before `save()`, the high-water mark reverts to the last persisted value on restart. The current-items scan ensures the generated-but-unsaved ID (which was added to `backlog.items` in memory) is not reused. This is safe because: if the crash was before `save()`, neither the new item nor the high-water mark persisted, so no collision; if the crash was after `save()`, both persisted atomically.

## Constraints

- Must use `#[serde(default)]` for backward compatibility — existing `BACKLOG.yaml` files must load without modification.
- The field lives in `BacklogFile`, not `orchestrate.toml`, because it is orchestrator-managed internal state, not human-editable configuration.
- Inside `ingest_follow_ups()`, `generate_next_id()` is called once per follow-up in a loop. Each call must see the updated high-water mark from previous iterations. Since `generate_next_id()` is pure, the caller must update `backlog.next_item_id` after each call (not just at the end of the loop). The items-push already ensures current-items-max stays correct between iterations; the explicit high-water mark update ensures the persisted floor also stays correct.
- The prefix is read once from `orchestrate.toml` at initialization and is assumed immutable for the life of the orchestrator session.

## Dependencies

- **Depends On:** Nothing — this is a standalone change to `backlog.rs` and `types.rs`.
- **Blocks:** Nothing directly, but WRK-026 (inbox ingestion) will also call `generate_next_id()` to assign IDs to ingested items, and will benefit from this fix being in place first.

## Risks

- [ ] **Off-by-one in naming:** Mitigated by choosing `next_item_id` (the suffix to use next) rather than `last_assigned_id`. The formula is `max(current_max, next_item_id) + 1`, and the returned suffix is `max + 1`, which becomes the new `next_item_id`. Unit tests verify this.
- [ ] **Stale high-water mark after manual YAML edits:** If a user manually adds items with IDs higher than the high-water mark, the scan of current items handles this correctly (we take the max of both). No risk here.
- [ ] **Crash between ID generation and save:** Safe — see Data Safety in Non-Functional Requirements. No collision possible because both the item and high-water mark are either persisted together or neither is persisted.

## Open Questions

None — this change is well-understood from the scoping phase.

## Assumptions

- Single-prefix assumption: The codebase uses one prefix (from `orchestrate.toml`). `next_item_id` is a single `u32`, not a per-prefix map.
- No schema version bump needed: Adding an optional field with `#[serde(default)]` is backward-compatible.
- One-time migration gap accepted: Existing backlogs without `next_item_id` default to 0. If all items have already been archived, the first new ID will start from `WRK-001` (since no current items exist and the default is 0). This is the same behavior as before the change. The high-water mark becomes correct immediately after the first ID is generated and saved.
- `generate_next_id()` return type change: The function signature changes from returning `String` to returning `(String, u32)` — the ID string and the new numeric suffix. All callers must be updated.

## References

- `generate_next_id()`: `orchestrator/src/backlog.rs:85-105`
- `BacklogFile` struct: `orchestrator/src/types.rs:190-195`
- `archive_item()`: `orchestrator/src/backlog.rs:200-225`
- `ingest_follow_ups()`: `orchestrator/src/backlog.rs:227-271`
- `save()` (atomic write): `orchestrator/src/backlog.rs:49-83`
